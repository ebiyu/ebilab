
# ebilab

## コンセプト

`ebilab`は、研究者が実験コードの複雑な部分（GUI、スレッド、非同期処理など）を意識することなく、**実験の本質的なロジックに集中できる**環境を提供することを目的とします。

* **宣言的なAPI**: ユーザーは「何をするか」をクラスやパラメータとして宣言的に記述します。
* **疎結合アーキテクチャ**: UI、コアロジック、実験定義を明確に分離し、高いテスト容易性と拡張性を実現します。
* **安全性と再現性**: 実験のライフサイクルをフレームワークが管理することで、安全な中断処理とクリーンな実行環境を保証します。

ユーザーが直接触れるAPIは、シンプルかつ直感的に設計されています。

ユーザーが書くスクリプトの例: `r_continuous_new.py` / `random_walk_new.py`

### `Experiment` クラス
`BaseExperiment` クラス を継承し、実験のパラメータとライフサイクルを定義します。

* **パラメータ**: `IntField`, `FloatField`, `SelectField`, `StrField`, `BoolField`などの**フィールドクラス**をクラスメンバとして定義し、GUIとバリデーションを自動生成します。
* **ライフサイクル**: `async def`で統一された以下の3つのメソッドを実装します。
    * `setup()`: 実験の準備
    * `steps()`: データを`yield`するメインループ
    * `cleanup()`: 正常終了・中断・エラー時に必ず呼ばれる後処理
- `self.logger` を通じてログも出力されます。

### `Plotter` クラス
`BasePlotter` クラスを継承し、可視化ロジックをカプセル化します。

* `@Experiment.register_plotter`デコレータで`Experiment`に関連付けられます。
* `update()`メソッドを実装し、`yield`されたデータに基づいた描画ロジックを記述します。

### スレッドモデル

実験はスレッドで実施されます。

* **実験ごとのスレッド**: 安全性とリソース分離のため、実験は**開始されるたびに新しいワーカースレッドを生成**します。
* **`ExperimentService`**: 一回の実験実行（`setup`から`cleanup`まで）の責務を持つクラス。実験のライフサイクル管理、スレッド管理、データ保存を統合的に担います。
* **イベントループ**: `ExperimentService`は、`asyncio.run()`を通じて、専用スレッド内で独立したイベントループを構築・実行します。

### 将来実装する機能: 監視モード
`with ebilab.monitor() as monitor:`構文を使い、`yield`を使わない既存のPythonスクリプトに`monitor.update(data)`を挿入するだけで、その進捗をリアルタイムに可視化します。

## 開発環境

- 開発ステージ: `v3` のリリース前で開発中。ほぼ全体的に再実装の途中。
- ToDoは `TODO.md` に記載されている。適宜更新すること。
- 修正が完了したらフォーマッタの実行、lintチェックを行う。
- フォーマットは `uvx ruff format` で実行。
- Lintは `uvx ruff check --fix` で実行。
